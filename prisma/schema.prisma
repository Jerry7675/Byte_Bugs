generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
	provider = "postgresql"
}
// prisma/schema.prisma

enum UserRole {
  INVESTOR
  STARTUP
  ADMIN
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum VerificationType {
  IDENTITY
  ROLE
  ACTIVITY
  COMMUNITY
}

enum VerificationStageStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
}

enum VerificationActor {
  USER
  ADMIN
  SYSTEM
}

enum CategoryType {
  FUNDING
  TECHNOLOGY
  MARKETING
  OPERATIONS
  GENERAL
}

enum PostType {
  FUNDING_REQUEST
  INVESTMENT_OFFER
  UPDATE
  ANNOUNCEMENT
  MILESTONE
  OTHER
}

enum PointsTxType {
  PURCHASE
  SPEND
  REFUND
  ADJUSTMENT
}

enum ConversationStatus {
  PENDING
  ACTIVE
  REJECTED
  CLOSED
}

enum FundingAgreementStatus {
  PENDING_INVESTOR
  PENDING_STARTUP
  ACCEPTED
  REJECTED
  CANCELLED
  COMPLETED
}

enum FundingCategory {
  SEED
  SERIES_A
  SERIES_B
  SERIES_C
  BRIDGE
  VENTURE_DEBT
  ANGEL
  STRATEGIC
  OTHER
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  password      String
  role          UserRole
  firstName     String
  middleName    String?
  lastName      String
  dob           DateTime
  phoneNumber   String

  isVerified    Boolean  @default(false)
  verifiedAt    DateTime?
  JWtToken      String?
  JwtIssuedAt  DateTime?

  sessions      Session[]
  wallet        PointsWallet?
  investor      InvestorProfile?
  startup       StartupProfile?

  sentReviews   Review[] @relation("Reviewer")
  receivedReviews Review[] @relation("Reviewee")

  conversationsAsRequester Conversation[] @relation("Requester")
  conversationsAsReceiver  Conversation[] @relation("Receiver")

  messages      Message[]
  promotions    Promotion[]
  adminActions  AdminAction[]
  otp           OTP?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  verificationApplications VerificationApplication[]
  posts                    Post[]
  reviewedVerifications    VerificationApplication[] @relation("VerificationReviewer")
  
  // Multi-stage verification
  verificationStages       VerificationStage[]
  reviewedStages          VerificationStage[] @relation("StageReviewer")
  activityMetrics         ActivityMetric?
  communityMetrics        CommunityMetric?
  
  // Daily message quota tracking
  messageQuota            MessageQuota?
  
  // Funding agreements
  initiatedFundingAgreements  FundingAgreement[] @relation("AgreementInitiator")
  receivedFundingAgreements   FundingAgreement[] @relation("AgreementCounterparty")
  
  // Successful fundings
  investorFundings            SuccessfulFunding[] @relation("FundingInvestor")
  startupFundings             SuccessfulFunding[] @relation("FundingStartup")
  
  // Swipe interactions
  swipesGiven                 SwipeInteraction[] @relation("Swiper")
  swipesReceived              SwipeInteraction[] @relation("SwipedProfile")
  swipeQuota                  SwipeQuota?
  
  // Matches
  matchesAsUser1              ProfileMatch[] @relation("MatchUser1")
  matchesAsUser2              ProfileMatch[] @relation("MatchUser2")
}

model Session {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  accessToken String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  expiresAt   DateTime
  revokedAt   DateTime?
  userAgent   String?
  ipAddress   String?
}

model PointsWallet {
  id        String @id @default(uuid())
  user      User   @relation(fields: [userId], references: [id])
  userId    String @unique
  balance   Int    @default(0)

  transactions PointsTransaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PointsTransaction {
  id        String        @id @default(uuid())
  wallet    PointsWallet @relation(fields: [walletId], references: [id])
  walletId  String
  amount    Int           // +credit, -debit
  type      PointsTxType
  reference String?       // payment id / conversation id
  note      String?
  status    String        @default("pending") // pending, success, failed
  balanceBefore Int?
  balanceAfter  Int?

  createdAt DateTime @default(now())
}

model InvestorProfile {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String   @unique

  bio         String?
  firmName    String?
  website     String?
  minTicket   Int?
  maxTicket   Int?

  photo       String? // URL or path to profile photo
  kycDocumentType String? // e.g., 'passport', 'aadhaar', etc.
  kycDocumentNumber String?
  kycDocumentUrl String? // URL or path to uploaded KYC document

  categories  CategoryType[] @default([])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model StartupProfile {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String   @unique

  name        String
  bio         String?  // Short bio for profile display
  description String?  // Detailed description
  website     String?
  stage       String?   // idea, seed, series-a (string for MVP)

  photo       String? // URL or path to profile photo
  kycDocumentType String? // e.g., 'incorporation', 'gst', etc.
  kycDocumentNumber String?
  kycDocumentUrl String? // URL or path to uploaded KYC document

  categories  CategoryType[] @default([])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Conversation {
  id            String   @id @default(uuid())
  requester     User     @relation("Requester", fields: [requesterId], references: [id])
  requesterId   String
  receiver      User     @relation("Receiver", fields: [receiverId], references: [id])
  receiverId    String

  status        ConversationStatus @default(PENDING)
  pointsCost    Int

  messages      Message[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([requesterId, receiverId])
}

model Message {
  id             String        @id @default(uuid())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  sender         User          @relation(fields: [senderId], references: [id])
  senderId       String
  content        String

  // Disappearing message feature
  expiresAt      DateTime?     // Absolute expiration timestamp (min 1 hour from creation)
  isExpired      Boolean       @default(false) // Soft delete flag for cleanup
  
  // Read status (optional for future enhancement)
  isRead         Boolean       @default(false)
  readAt         DateTime?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  @@index([conversationId, createdAt])
  @@index([expiresAt])
  @@index([senderId])
}

model Review {
  id          String @id @default(uuid())
  reviewer    User   @relation("Reviewer", fields: [reviewerId], references: [id])
  reviewerId  String
  reviewee    User   @relation("Reviewee", fields: [revieweeId], references: [id])
  revieweeId  String

  rating      Int    // 1â€“5
  comment     String?

  createdAt   DateTime @default(now())
  isVerified    Boolean  @default(false)
  verifiedAt    DateTime?
}

model Promotion {
  id          String @id @default(uuid())
  user        User   @relation(fields: [userId], references: [id])
  userId      String
  pointsSpent Int
  startsAt    DateTime
  endsAt      DateTime
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
}

model VerificationApplication {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  status      VerificationStatus @default(PENDING)
  companyName String?
  domain      String?
  documents   String? // comma-separated links or JSON
  appliedAt   DateTime @default(now())
  reviewedAt  DateTime?
  reviewerId  String?
  reviewer    User?    @relation("VerificationReviewer", fields: [reviewerId], references: [id])
  note        String?
}

model Post {
  id          String       @id @default(uuid())
  author      User         @relation(fields: [authorId], references: [id])
  authorId    String
  title       String
  content     String
  imageUrl    String?      // Supabase S3 URL
  category    CategoryType
  postType    PostType     @default(UPDATE)
  tags        String[]     @default([])
  
  // Boost feature fields
  isBoosted   Boolean      @default(false)
  boostedAt   DateTime?
  boostExpiresAt DateTime?
  boostCost   Int?         // Points spent on boost
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  
  @@index([authorId])
  @@index([category])
  @@index([postType])
  @@index([isBoosted, boostExpiresAt])
}

model AdminAction {
  id        String @id @default(uuid())
  admin     User   @relation(fields: [adminId], references: [id])
  adminId   String
  action    String
  targetId  String?
  note      String?

  createdAt DateTime @default(now())
}

model OTP {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @unique
  hashedOtp String
  attempts  Int      @default(0)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

// Multi-Stage Verification System

model VerificationStage {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  
  type        VerificationType
  status      VerificationStageStatus @default(PENDING)
  

  metadata    Json?
  
  // Audit trail
  submittedBy VerificationActor @default(USER)
  reviewedBy  VerificationActor?
  reviewer    User?    @relation("StageReviewer", fields: [reviewerId], references: [id])
  reviewerId  String?
  reviewNote  String?
  
  // Auto-expiry for time-limited verifications
  expiresAt   DateTime?
  
  submittedAt DateTime @default(now())
  reviewedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId, type])
  @@index([status])
  @@index([type])
}

model ActivityMetric {
  id                    String   @id @default(uuid())
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                String   @unique
  
  // Interaction metrics
  conversationsStarted  Int      @default(0)
  conversationsReceived Int      @default(0)
  messagesExchanged     Int      @default(0)
  
  // Platform engagement
  postsCreated          Int      @default(0)
  reviewsGiven          Int      @default(0)
  reviewsReceived       Int      @default(0)
  
  // Investment/Deal metrics (role-specific)
  dealsInitiated        Int      @default(0)
  dealsCompleted        Int      @default(0)
  
  // Calculated score (0-100)
  activityScore         Float    @default(0)
  
  lastCalculatedAt      DateTime @default(now())
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

model CommunityMetric {
  id                  String   @id @default(uuid())
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              String   @unique
  
  // Trust indicators
  averageRating       Float    @default(0)
  totalReviews        Int      @default(0)
  verifiedReviews     Int      @default(0)
  
  // Endorsements (can be from other verified users)
  endorsementCount    Int      @default(0)
  endorsedByVerified  Int      @default(0)
  
  // Response metrics
  responseRate        Float    @default(0)
  averageResponseTime Int?     // in minutes
  
  // Calculated trust score (0-100)
  trustScore          Float    @default(0)
  
  lastCalculatedAt    DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

// Daily message quota tracking (20 free messages per day, then points-based)
model MessageQuota {
  id                String   @id @default(uuid())
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String   @unique
  
  // Daily quota tracking
  messagesSentToday Int      @default(0)
  quotaDate         DateTime @default(now()) // Date for which this quota applies
  
  // Configuration
  dailyFreeLimit    Int      @default(20)
  pointsPerMessage  Int      @default(10) // Points to deduct after free limit
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([userId, quotaDate])
}

// Funding Agreement - Negotiation Phase
model FundingAgreement {
  id                String   @id @default(uuid())
  
  // Parties
  initiator         User     @relation("AgreementInitiator", fields: [initiatorId], references: [id])
  initiatorId       String
  counterparty      User     @relation("AgreementCounterparty", fields: [counterpartyId], references: [id])
  counterpartyId    String
  
  // Agreement details
  category          FundingCategory
  fundingAmount     Decimal  @db.Decimal(15, 2) // Total funding amount
  platformCommissionRate Decimal @default(5.0) @db.Decimal(5, 2) // Platform commission percentage (e.g., 5.00 = 5%)
  platformCommission     Decimal @db.Decimal(15, 2) // Calculated commission amount
  netAmount              Decimal @db.Decimal(15, 2) // Amount after commission
  
  // Terms acceptance
  termsVersion      String   // e.g., "v1.0.0" - tracks which version of platform terms was accepted
  termsAcceptedByInitiator    Boolean @default(false)
  termsAcceptedByCounterparty Boolean @default(false)
  initiatorAcceptedAt         DateTime?
  counterpartyAcceptedAt      DateTime?
  
  // Status and workflow
  status            FundingAgreementStatus @default(PENDING_INVESTOR)
  
  // Rejection/Cancellation
  rejectedBy        String?  // userId who rejected
  rejectionReason   String?
  cancelledBy       String?  // userId who cancelled
  cancellationReason String?
  
  // Audit trail
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  completedAt       DateTime? // When both parties accepted
  
  // Reference to successful funding (if completed)
  successfulFunding SuccessfulFunding?
  
  @@index([initiatorId])
  @@index([counterpartyId])
  @@index([status])
  @@index([createdAt])
}

// Successful Funding - Immutable Record
model SuccessfulFunding {
  id                String   @id @default(uuid())
  
  // Reference to original agreement
  agreement         FundingAgreement @relation(fields: [agreementId], references: [id])
  agreementId       String   @unique
  
  // Parties (denormalized for immutability)
  investor          User     @relation("FundingInvestor", fields: [investorId], references: [id])
  investorId        String
  startup           User     @relation("FundingStartup", fields: [startupId], references: [id])
  startupId         String
  
  // Financial details (denormalized snapshot)
  category          FundingCategory
  fundingAmount     Decimal  @db.Decimal(15, 2)
  platformCommission Decimal @db.Decimal(15, 2)
  netAmount         Decimal  @db.Decimal(15, 2)
  
  // Terms reference
  termsVersion      String
  
  // Immutable record metadata
  completedAt       DateTime @default(now())
  createdAt         DateTime @default(now())
  
  // TODO: Add payment settlement tracking when integrated with payment gateway
  // paymentStatus     String?
  // paymentReference  String?
  // paymentCompletedAt DateTime?
  
  @@index([investorId, completedAt])
  @@index([startupId, completedAt])
  @@index([completedAt])
}

// Swipe Interaction - Tinder-like Matching System
enum SwipeAction {
  LIKE
  DISLIKE
  SKIP
}

model SwipeInteraction {
  id                String      @id @default(uuid())
  
  // Who swiped
  swiper            User        @relation("Swiper", fields: [swiperId], references: [id])
  swiperId          String
  
  // Who was swiped on
  swipedProfile     User        @relation("SwipedProfile", fields: [swipedProfileId], references: [id])
  swipedProfileId   String
  
  // Swipe action
  action            SwipeAction
  
  // Metadata
  createdAt         DateTime    @default(now())
  
  @@index([swiperId, createdAt])
  @@index([swipedProfileId])
  @@index([swiperId, swipedProfileId])
  @@unique([swiperId, swipedProfileId]) // Prevent duplicate swipes on same profile
}

// Daily Swipe Quota - 10 free swipes per day
model SwipeQuota {
  id                String   @id @default(uuid())
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String   @unique
  
  // Daily quota tracking
  swipesToday       Int      @default(0)
  quotaDate         DateTime @default(now()) // Date for which this quota applies
  
  // Last skipped profile for undo functionality
  lastSkippedProfileId String?
  lastSkipTime      DateTime?
  
  // Configuration
  dailyFreeLimit    Int      @default(10)
  pointsPerSwipe    Int      @default(5)   // Points to deduct after free limit
  pointsPerUndo     Int      @default(10)  // Points to deduct for undo action
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([userId, quotaDate])
}

// Profile Match - When both users like each other
model ProfileMatch {
  id                String   @id @default(uuid())
  
  // The two matched users
  user1             User     @relation("MatchUser1", fields: [user1Id], references: [id])
  user1Id           String
  user2             User     @relation("MatchUser2", fields: [user2Id], references: [id])
  user2Id           String
  
  // Match metadata
  matchedAt         DateTime @default(now())
  isActive          Boolean  @default(true) // Can be set to false if either user unmatches
  
  createdAt         DateTime @default(now())
  
  @@index([user1Id])
  @@index([user2Id])
  @@unique([user1Id, user2Id])
}

