/**
 * Activity Metrics Service
 *
 * Automatically tracks and calculates activity-based verification metrics
 * This service should be called after relevant user actions (conversations, posts, deals)
 */

import { getContext } from '@/context/context-store';
import { PrismaEnums } from '@/enumWrapper';

export class ActivityMetricsService {
  /**
   * Initialize activity metrics for a new user
   */
  static async initializeMetrics(userId: string) {
    const { prisma } = getContext();

    const existing = await prisma.activityMetric.findUnique({
      where: { userId },
    });

    if (existing) return existing;

    return prisma.activityMetric.create({
      data: {
        userId,
        activityScore: 0,
      },
    });
  }

  /**
   * Recalculate activity score for a user
   * Should be called periodically or after significant events
   */
  static async recalculateActivityScore(userId: string) {
    const { prisma } = getContext();

    // Get all activity data
    const [
      conversationsStarted,
      conversationsReceived,
      messages,
      posts,
      reviewsGiven,
      reviewsReceived,
    ] = await Promise.all([
      prisma.conversation.count({ where: { requesterId: userId } }),
      prisma.conversation.count({ where: { receiverId: userId } }),
      prisma.message.count({ where: { senderId: userId } }),
      prisma.post.count({ where: { authorId: userId } }),
      prisma.review.count({ where: { reviewerId: userId } }),
      prisma.review.count({ where: { revieweeId: userId } }),
    ]);

    // Calculate score (0-100)
    // This is a simple weighted formula - adjust based on your business logic
    const score = Math.min(
      100,
      conversationsStarted * 2 +
        conversationsReceived * 2 +
        Math.min(messages / 10, 20) +
        posts * 5 +
        reviewsGiven * 3 +
        reviewsReceived * 2,
    );

    // Update or create metrics
    const metric = await prisma.activityMetric.upsert({
      where: { userId },
      update: {
        conversationsStarted,
        conversationsReceived,
        messagesExchanged: messages,
        postsCreated: posts,
        reviewsGiven,
        reviewsReceived,
        activityScore: score,
        lastCalculatedAt: new Date(),
      },
      create: {
        userId,
        conversationsStarted,
        conversationsReceived,
        messagesExchanged: messages,
        postsCreated: posts,
        reviewsGiven,
        reviewsReceived,
        activityScore: score,
      },
    });

    // Auto-create activity verification if score is high enough
    if (score >= 50) {
      await this.autoSubmitActivityVerification(userId, score);
    }

    return metric;
  }

  /**
   * Automatically submit activity verification when threshold is reached
   */
  private static async autoSubmitActivityVerification(userId: string, score: number) {
    const { prisma } = getContext();

    // Check if already has approved activity verification
    const existing = await prisma.verificationStage.findFirst({
      where: {
        userId,
        type: PrismaEnums.VerificationType.ACTIVITY,
        status: PrismaEnums.VerificationStageStatus.APPROVED,
      },
    });

    if (existing) return;

    // Check if there's a pending one
    const pending = await prisma.verificationStage.findFirst({
      where: {
        userId,
        type: PrismaEnums.VerificationType.ACTIVITY,
        status: {
          in: [
            PrismaEnums.VerificationStageStatus.PENDING,
            PrismaEnums.VerificationStageStatus.IN_REVIEW,
          ],
        },
      },
    });

    if (pending) return;

    // Auto-approve activity verification if score is high enough
    await prisma.verificationStage.create({
      data: {
        userId,
        type: PrismaEnums.VerificationType.ACTIVITY,
        status: PrismaEnums.VerificationStageStatus.APPROVED,
        metadata: {
          score,
          autoGenerated: true,
          generatedAt: new Date().toISOString(),
        },
        submittedBy: PrismaEnums.VerificationActor.SYSTEM,
        reviewedBy: PrismaEnums.VerificationActor.SYSTEM,
        reviewedAt: new Date(),
        reviewNote: `Automatically approved based on activity score of ${score}`,
      },
    });
  }

  /**
   * Increment specific activity metrics
   */
  static async incrementMetric(
    userId: string,
    metric: 'conversation' | 'message' | 'post' | 'review' | 'deal',
  ) {
    const { prisma } = getContext();

    await this.initializeMetrics(userId);

    const updates: any = {};

    switch (metric) {
      case 'conversation':
        updates.conversationsStarted = { increment: 1 };
        break;
      case 'message':
        updates.messagesExchanged = { increment: 1 };
        break;
      case 'post':
        updates.postsCreated = { increment: 1 };
        break;
      case 'review':
        updates.reviewsGiven = { increment: 1 };
        break;
      case 'deal':
        updates.dealsInitiated = { increment: 1 };
        break;
    }

    await prisma.activityMetric.update({
      where: { userId },
      data: updates,
    });

    // Recalculate score after update
    return this.recalculateActivityScore(userId);
  }

  /**
   * Get activity metrics for a user
   */
  static async getMetrics(userId: string) {
    const { prisma } = getContext();

    const metric = await prisma.activityMetric.findUnique({
      where: { userId },
    });

    if (!metric) {
      return this.initializeMetrics(userId);
    }

    return metric;
  }
}
