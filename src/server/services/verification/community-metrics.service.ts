/**
 * Community Metrics Service
 *
 * Tracks and calculates community trust-based verification metrics
 * Based on reviews, endorsements, and response patterns
 */

import { getContext } from '@/context/context-store';
import { PrismaEnums } from '@/enumWrapper';

export class CommunityMetricsService {
  /**
   * Initialize community metrics for a new user
   */
  static async initializeMetrics(userId: string) {
    const { prisma } = getContext();

    const existing = await prisma.communityMetric.findUnique({
      where: { userId },
    });

    if (existing) return existing;

    return prisma.communityMetric.create({
      data: {
        userId,
        trustScore: 0,
      },
    });
  }

  /**
   * Recalculate community trust score for a user
   */
  static async recalculateTrustScore(userId: string) {
    const { prisma } = getContext();

    // Get review data
    const reviews = await prisma.review.findMany({
      where: { revieweeId: userId },
    });

    const totalReviews = reviews.length;
    const verifiedReviews = reviews.filter((r) => r.isVerified).length;
    const averageRating =
      totalReviews > 0 ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews : 0;

    // Get conversation response metrics
    const conversations = await prisma.conversation.findMany({
      where: { receiverId: userId },
      include: {
        messages: {
          where: { senderId: userId },
          orderBy: { createdAt: 'asc' },
          take: 1,
        },
      },
    });

    let totalResponseTime = 0;
    let responseCount = 0;

    conversations.forEach((conv) => {
      if (conv.messages.length > 0) {
        const responseTime = conv.messages[0].createdAt.getTime() - conv.createdAt.getTime();
        totalResponseTime += responseTime;
        responseCount++;
      }
    });

    const responseRate =
      conversations.length > 0 ? (responseCount / conversations.length) * 100 : 0;

    const averageResponseTime =
      responseCount > 0
        ? Math.floor(totalResponseTime / responseCount / 1000 / 60) // in minutes
        : null;

    // Calculate trust score (0-100)
    // Weighted formula based on various trust signals
    const ratingScore = (averageRating / 5) * 40; // Max 40 points
    const reviewCountScore = Math.min(totalReviews * 2, 20); // Max 20 points
    const verifiedReviewScore = Math.min(verifiedReviews * 3, 20); // Max 20 points
    const responseScore = (responseRate / 100) * 20; // Max 20 points

    const trustScore = Math.min(
      100,
      ratingScore + reviewCountScore + verifiedReviewScore + responseScore,
    );

    // Update or create metrics
    const metric = await prisma.communityMetric.upsert({
      where: { userId },
      update: {
        averageRating,
        totalReviews,
        verifiedReviews,
        responseRate,
        averageResponseTime,
        trustScore,
        lastCalculatedAt: new Date(),
      },
      create: {
        userId,
        averageRating,
        totalReviews,
        verifiedReviews,
        responseRate,
        averageResponseTime,
        trustScore,
      },
    });

    // Auto-create community verification if trust score is high enough
    if (trustScore >= 60 && totalReviews >= 3) {
      await this.autoSubmitCommunityVerification(userId, trustScore);
    }

    return metric;
  }

  /**
   * Automatically submit community verification when threshold is reached
   */
  private static async autoSubmitCommunityVerification(userId: string, trustScore: number) {
    const { prisma } = getContext();

    // Check if already has approved community verification
    const existing = await prisma.verificationStage.findFirst({
      where: {
        userId,
        type: PrismaEnums.VerificationType.COMMUNITY,
        status: PrismaEnums.VerificationStageStatus.APPROVED,
      },
    });

    if (existing) return;

    // Check if there's a pending one
    const pending = await prisma.verificationStage.findFirst({
      where: {
        userId,
        type: PrismaEnums.VerificationType.COMMUNITY,
        status: {
          in: [
            PrismaEnums.VerificationStageStatus.PENDING,
            PrismaEnums.VerificationStageStatus.IN_REVIEW,
          ],
        },
      },
    });

    if (pending) return;

    // Auto-approve community verification if trust score is high enough
    await prisma.verificationStage.create({
      data: {
        userId,
        type: PrismaEnums.VerificationType.COMMUNITY,
        status: PrismaEnums.VerificationStageStatus.APPROVED,
        metadata: {
          trustScore,
          autoGenerated: true,
          generatedAt: new Date().toISOString(),
        },
        submittedBy: PrismaEnums.VerificationActor.SYSTEM,
        reviewedBy: PrismaEnums.VerificationActor.SYSTEM,
        reviewedAt: new Date(),
        reviewNote: `Automatically approved based on trust score of ${trustScore.toFixed(2)}`,
      },
    });
  }

  /**
   * Add an endorsement (can be called when a verified user endorses another)
   */
  static async addEndorsement(userId: string, endorsedByVerified: boolean = false) {
    const { prisma } = getContext();

    await this.initializeMetrics(userId);

    await prisma.communityMetric.update({
      where: { userId },
      data: {
        endorsementCount: { increment: 1 },
        ...(endorsedByVerified && { endorsedByVerified: { increment: 1 } }),
      },
    });

    // Recalculate trust score
    return this.recalculateTrustScore(userId);
  }

  /**
   * Get community metrics for a user
   */
  static async getMetrics(userId: string) {
    const { prisma } = getContext();

    const metric = await prisma.communityMetric.findUnique({
      where: { userId },
    });

    if (!metric) {
      return this.initializeMetrics(userId);
    }

    return metric;
  }

  /**
   * Update metrics after a review is created
   */
  static async onReviewCreated(revieweeId: string) {
    return this.recalculateTrustScore(revieweeId);
  }

  /**
   * Update metrics after a review is verified
   */
  static async onReviewVerified(revieweeId: string) {
    return this.recalculateTrustScore(revieweeId);
  }
}
